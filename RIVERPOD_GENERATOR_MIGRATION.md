# Auth Controller Refactored with Riverpod Generator

The auth controller has been successfully refactored to use **Riverpod Generator** with **AsyncValue**, eliminating the need for manual state management and Freezed for state classes.

## What Changed

### Before (Manual StateNotifier)

```dart
class AuthState {
  final bool isLoading;
  final String? error;
  final bool isSuccess;
  final AuthUserModel? user;

  // Manual copyWith method
  AuthState copyWith({...}) {...}
}

class AuthController extends StateNotifier<AuthState> {
  // Manual constructor with dependencies
  AuthController({required this.loginUseCase}) : super(const AuthState());

  // Manual state management
  state = state.copyWith(isLoading: true, ...);
}

// Manual provider
final authControllerProvider = StateNotifierProvider<AuthController, AuthState>(...);
```

### After (Riverpod Generator with AsyncValue)

```dart
@riverpod
class AuthController extends _$AuthController {
  @override
  FutureOr<AuthUserModel?> build() => null;

  Future<void> login({...}) async {
    state = const AsyncValue.loading();
    // ... login logic
    state = AsyncValue.data(user);
  }
}

// Provider is auto-generated!
```

## Benefits

### 1. **No Manual State Class**

- No need to create `AuthState` class
- No need for `copyWith` method
- AsyncValue provides `loading`, `data`, and `error` states automatically

### 2. **Auto-Generated Provider**

- Provider is generated by build_runner
- No need to manually create `StateNotifierProvider`
- Type-safe and validated at compile time

### 3. **Simpler State Management**

```dart
// AsyncValue provides three states:
state = const AsyncValue.loading();  // Loading state
state = AsyncValue.data(user);       // Success state
state = AsyncValue.error(error, stack); // Error state
```

### 4. **Cleaner UI Code**

```dart
// Check loading state
authState.isLoading // true/false

// Get the data
final user = authState.value; // AuthUserModel? or null

// Handle all states
authState.when(
  data: (user) => Text('Welcome ${user?.name}'),
  loading: () => CircularProgressIndicator(),
  error: (err, stack) => Text('Error: $err'),
);
```

## Usage Examples

### In Login Page

```dart
// Listen to auth state changes
ref.listen<AsyncValue<AuthUserModel?>>(authControllerProvider, (previous, next) {
  next.when(
    data: (user) {
      if (user != null) {
        // Navigate to home
        context.go('/');
      }
    },
    loading: () {},
    error: (error, stack) {
      // Show error
      ScaffoldMessenger.of(context).showSnackBar(...);
    },
  );
});

// Show loading in button
ElevatedButton(
  onPressed: authState.isLoading ? null : _login,
  child: authState.when(
    data: (_) => Text('Login'),
    loading: () => CircularProgressIndicator(),
    error: (_, __) => Text('Login'),
  ),
);
```

### In Home Page

```dart
final authState = ref.watch(authControllerProvider);
final user = authState.value; // Get the user data

if (user != null) {
  // User is logged in
  Text('Welcome ${user.name}');
} else {
  // User is not logged in
  ElevatedButton(onPressed: () => context.go('/login'));
}
```

### In Input Page

```dart
final authState = ref.watch(authControllerProvider);
final user = authState.value;

if (user == null) {
  // Redirect to login
  context.go('/login');
  return CircularProgressIndicator();
}

// Use user data
_petugasController.text = user.name;
_usernameController.text = user.username;
```

## Files Modified

1. **lib/presentation/auth/auth_controller.dart**
   - Refactored to use `@riverpod` annotation
   - Uses `AsyncValue<AuthUserModel?>` instead of custom `AuthState`
   - Auto-generated provider

2. **lib/presentation/auth/login_page.dart**
   - Updated to use `AsyncValue`
   - Uses `.when()` method for state handling
   - Uses `.isLoading` for button state

3. **lib/presentation/home/home_page.dart**
   - Updated to use `.value` to get user data
   - Simplified null checks

4. **lib/presentation/input/input_page.dart**
   - Updated to use `.value` to get user data
   - Simplified authentication checks

## Generated Files

- `lib/presentation/auth/auth_controller.g.dart` - Auto-generated provider code
- `lib/presentation/auth/auth_controller.freezed.dart` - Not needed anymore (can be deleted)

## Key Differences from Example

The provided example uses:

```dart
@riverpod
class LoginNotifier extends _$LoginNotifier {
  @override
  FutureOr<LoginResponse?> build() => null;

  Future<void> login(LoginRequest request) async {
    state = const AsyncValue.loading();
    // ... logic
  }
}
```

Our implementation follows the same pattern:

```dart
@riverpod
class AuthController extends _$AuthController {
  @override
  FutureOr<AuthUserModel?> build() => null;

  Future<void> login({required String username, required String password}) async {
    state = const AsyncValue.loading();
    // ... logic
  }
}
```

## AsyncValue States

### Loading State

```dart
state = const AsyncValue.loading();
// UI: authState.isLoading == true
```

### Success State

```dart
state = AsyncValue.data(user);
// UI: authState.value == user (AuthUserModel)
```

### Error State

```dart
state = AsyncValue.error(errorMessage, stackTrace);
// UI: authState.error == errorMessage
```

## Migration Benefits

✅ **Less boilerplate code** - No manual state class
✅ **Auto-generated providers** - Type-safe and validated
✅ **Built-in loading/error states** - Provided by AsyncValue
✅ **Better error handling** - Stack traces included
✅ **Cleaner UI code** - Simple `.value` and `.when()` methods
✅ **Follows Riverpod best practices** - Uses code generation

## Next Steps

Consider removing the unused Freezed files:

- `lib/presentation/auth/auth_controller.freezed.dart` (if exists)

The refactored code is now cleaner, more maintainable, and follows modern Riverpod patterns!
